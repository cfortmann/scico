\documentclass[10pt,a4paper,titlepage]{article}
\usepackage{tabularx}
\usepackage{arydshln}
\usepackage{placeins}
\usepackage{hyperref}
\usepackage{subcaption}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{afterpage}
\usepackage[USenglish]{babel}
\usepackage{mdframed}
\usepackage{todonotes}
\usepackage{threeparttable}
\usepackage{framed}
\usepackage[a4paper, left=1.0cm, right=1.0cm, top=1.5cm, bottom=1.5cm]{geometry}
\setlength{\parindent}{0pt}
\usepackage{xspace}	

\usepackage[makeroom]{cancel}

\newcommand*{\tab}{&}
\newcommand*{\figca}[1]{\caption{#1}}

\usepackage{enumitem}
\setlist{leftmargin=3mm}
\usepackage{refcount}

\usepackage{cases}
\setlength{\parindent}{3em}

\usepackage{chngcntr}
\usepackage{multirow, multicol}
 \usepackage{float}

\counterwithin*{equation}{enumi}
\newcommand{\qr}{QR-Faktorisierung\xspace}
\newcommand{\luf}{LU-Faktorisierung\xspace}
\newcommand{\kui}{Kurven-Interpolation\xspace}
\newcommand{\kua}{Kurven-Approximation\xspace}
\newcommand{\chf}{Cholesky-Faktorisierung\xspace}
\newcommand{\schf}{Sparse \chf}
\usepackage{mathtools}
\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\usepackage{amsmath,amsfonts,amssymb,amsthm}
\usepackage{mathptmx}
\usepackage{calc}
\usepackage{wasysym}
\begin{document}	
\section{title}
\begin{enumerate}[series=b]
	\item Wie kann eine Wurfparabel approximiert werden?\newline
	\luf, \chf,..
	\item Wie werden $A$ und $b$ aufgestellt? \newline
	b beinhaltet die Werte $y_i$ der gegebenen Punkte. In $A$ werden die Basisfunktionen gespeichert, also zB. Monome (wie Übung) werden in der ersten Zeile die $x_1^{0...n}$ und in den Spalten $x_{1..n}$ gespeichert. Somit steht in der i-ten Zeile und j-ten Spalte der Eintrag $x_{i+1}^j$.
	\item Was ist eine Basisfunktion? \newline
	\textbf{Eine Basisfunktion beschreibt eine Kurve indem die Kurve als eine endliche Anzahl von Parametern beschreibt. Die von uns verwendete Basisfunktion ist die Monom-Basis $x^i$}
	\item Wie funktioniert \luf und wie löst man das Gleichungssystem? \newline
	      Faktorisierung von A in untere (L) und obere Dreiecksmatrix (U) mittels Gau{\ss}.\\
	      $	
	      \begin{pmatrix}
		* & * & * & *\\
		* & * & * & *\\
		* & * & * & *\\
		* & * & * & *
	      \end{pmatrix}
	      \rightarrow
	      \begin{pmatrix}
		* & * & * & *\\
		0 & * & * & *\\
		0 & * & * & *\\
		0 & * & * & *
	      \end{pmatrix}
	      \rightarrow
              \dots
              $\\
	      Zum Lösen dann (1) $Ly = b$ und (2) $Ux = y$ lösen.\\
	      Vorwärtssubstitution für (1):\\
              Erstes Element: $y_1 = \frac{b_1}{l_{11}}$ \\
	      $ y_i = \frac{1}{l_{ii}} (b_i - \sum_{j=1}^{i-1} l_{ii}y_{j} )$ für $i = 2, \dots, m$.\\
	      Rückwärts für (2): \\
	      $ x_1 = \frac{y_m}{u_{mm}}$ \\
	      $x_i = \frac{1}{u_{ii}} (y_i - \sum_{j=i+1}^{m} u_{ij}x_j)$ für $i = m-1, \dots, 1$. 

	\item Wie kann man \luf stabiler machen?\newline
	Pivotisierung der Matrix, mittels Permutationsmatrix
	\item Was ist der Aufwand? \newline
	$PA=LU$: $\frac{2}{3}m^3$ FLOPs
	\item Wann geht der \luf kaputt?
	\textbf{Die \luf scheitert sobald der Algorithmus versucht eine Division durch 0 durchzuführen. Bsp Matrix} $\begin{pmatrix}
	0&1\\
	1&1
	\end{pmatrix}$
	
\end{enumerate}
\section{title}
\begin{enumerate}[resume=b]
	\item Was ist der Unterschied zwischen Approx und Interpolation?
	      Polynomgrad bzw. Dimensionen der Matrix $A^{m \times n}$.\\
	      \begin{itemize}
	      \item $m = n$: $A$ quadratisch, voller Rang, existiert inverse, dann eindeutige Lösung.
              \item $m > n$: System überbestimmt, nicht exakt lösbar. Approximation  
              \end{itemize}
	\item Wie kann ein überbestimmtes Gleichungssystem approximiert werden?\newline
	Normalengleichung mit folgender \luf, \chf, SVD,..
	\item Warum sollte man manchmal ein Polynom kleineren Grades finden? \newline
	Durch ein Polynom mit einem kleineren Grad können verrauschte Daten besser approximiert werden. 
	\item Was ist der Grad eines Polynomes?\newline
	\textbf{Der grad eines Polynoms entspricht dessen höchster Potenz}
	\item Was sind Normalengleichungen und wie sind sie definiert? Welche Dim hat $A^TA$?\\
              Erster Teil siehe nächste Frage/Antwort.\\
              $A^TA \in (n \times n)$.
	\item Wie leitet man die Normalengleichung her?\newline
	3 Herleitungen, geometrische: \begin{align*}
	Ax=b & \text{ nicht lösbar, da }b \text{ nicht in }range(A)\\
	&\Rightarrow\;y\text{ ist orthognoale Projektion von } b \text{ auf }range(A)\\
	&\Rightarrow r=b-Ax\\
	\|r\|\rightarrow\text{min} &\Leftrightarrow r\perp range(A) = \langle a_1,..,a_n\rangle\\
	&\Leftrightarrow r\perp a_j, j=1,..,n\\
	&\Leftrightarrow a_j^T r=\|a_j\|\cdot\|r\|\cdot cos(a_j,r)=0\\
	&\Leftrightarrow A^Tr=0\\
	&\Leftrightarrow A^T(b-Ax)=0\\
	&\Leftrightarrow A^Tb-A^TAx=0\\
	&\Leftrightarrow A^TAx=A^Tb
	\end{align*}
	\item Was ist die 2-Norm? \newline
	$||x||_2=\sqrt{\sum_i x_i^2}$
	\item Wann ist eine Matrix symmetrisch positiv definit?\newline
	\textbf{Eine Matrix is symmetrisch wenn : $A^T=A$ und sie ist positiv definit wenn gilt:$\forall x \neq 0; \; x^T \cdot A \cdot x > 0$}
	\item Welcher Löser muss verwendet werden, wenn A nicht quadratisch ist? \\
              Cholesky, QR oder SVD. Je nach Eigenschaften von A.
	\item Was ist der Unterschied zwischen \chf und \qr?
	\newline
	\begin{tabular}{c|c}
		\qr & \chf\\\hline
		eher geometrisch (Basiswechsel) & eher analytisch\\ 
	\end{tabular}\newline
	\todo[inline]{mehr schreiben}
	\item Was ist \chf? Wie funktioniert sie? \newline
	Robuster, effizienter Löser für spd Matrizen. Das Verfahren basiert auf der symmetrischen Gauß-Elimination. Dabei wird die Matrix $A$ in die Faktoren $L$ und $L^T$ zerlegt.  $A=\begin{pmatrix}
	a_{11} & w^T \\
	w & K
	\end{pmatrix}$ \newline
	$A=\begin{pmatrix}	                                                                                                                                                                              \sqrt{a_{11}} & 0 \\
	\frac{w}{\sqrt{a_{11}}} & I
	\end{pmatrix} 
	\begin{pmatrix}	                                                                                                                                                                              1 & 0 \\
	0 & \tilde{L}\tilde{L^T}
	\end{pmatrix}                                                                                                                                                                            
	\begin{pmatrix}	                                                                                                                                                                              \sqrt{a_{11}} & \frac{w^T}{\sqrt{a_{11}}} \\
	0 & I
	\end{pmatrix}   
	=
	\begin{pmatrix}	                                                                                                                                                                              \sqrt{a_{11}} & 0 \\
	\frac{w}{\sqrt{a_{11}}} & \tilde{L}
	\end{pmatrix} 
	\begin{pmatrix}	                                                                                                                                                                              \sqrt{a_{11}} & \frac{w^T}{\sqrt{a_{11}}} \\
	0 & \tilde{L^T}
	\end{pmatrix}  = LL^T$  \newline
	Im Algorithmus wird $L=A$ initialisiert und das obere Dreieck auf $0$ gesetzt. Mit 3 for-Schleifen (aufgrund MatLab Schreibweise) werden dann die Elemente der Spalte wie folgt berechnet: $L(i,j)=L(i,j)-L(i,k)*(L(j,k)/L(k,k))$. Der Wert $x=1/sqrt(L(k,k))$ wird seperat berechnet und zum Schluss werden die Elemente der Spalte durch $L(i,k)=L(i,k)*x$ endgültig berechnet.
	\item Was ist fill-in und wie kommt es zustande?\newline
	\textbf{Fill-in beschreibt das eine $a_{ij}=0$ in A ist, aber nach der Faktorisierung mit Cholesky $a_{ij} \neq 0$. Fill-in tritt nur innerhlab des Bandes azf alles Nullen außerhalb des Bandes bleiben erhalten.
		Es ensteht durch die gebildete differenz $K-ww^T$.}
	\item Wie funktioniert \qr? \\
	\begin{itemize}
           \item Erst orthonormale Basis $\{q_1,\dots,q_n\}$ von range$(A)$ konstruieren (Gram-Schmidt)
	   \item Dann sind Vektoren aus $A$ darstellbar in der gefundenen Basis $\{q_1,\dots,q_n\}$.
           \item $a_1 = r_{11}q_1, \dots, a_n = r_{1n}q_1 + \dots + r_{nn}q_n$. (Gram-Schmidt liefert auch Koeffizienten $r$)
	   \item in Matrixschreibweise zusammengefasst ergibt sich: $A = QR$
	\end{itemize}
        Für die Lösung eines least-squares Problems:
	\begin{itemize}
		\item QR-Faktorisierung $A=QR$ (siehe oben).
		\item Berechne $b' = Q^Tb$
		\item Löse $Rx = b'$ durch Rückwärtssubstitution.
	\end{itemize}
	\item Was ist eine orthogonale Projektion?\newline
	Entspricht der Projektion eines Punktes $b$ auf das Bild einer Matrix $A$\\
	beginne mit Projektion von $b$ auf $\langle A\rangle$, mit $\|A\|=1$\\
	$r=b-b'=(I-AA^T)b$, mit $b'=\left(\sum_{i=1}^{k}A_iA_i^T\right)b=\hat{A}\hat{A}^Tb$ mit $\hat{A}\hat{A}^T$ als orthogonale Projektion
	\item Wann ist A von vollem Rang? \newline 
	Die Matrix hat den vollen Rang, wenn: $rank ( A ) = n$ $\Leftrightarrow$ $dim ( range ( A )) = n$ $\Leftrightarrow$ $dim < a_1 , . . . , a_n> i = n$ $\Leftrightarrow$ Spalten $a_j$ linear unabhängig $\Leftrightarrow$ $null ( A ) = { 0 }$
	
	\todo[inline]{SVD-Bild einfügen aus Skript S.47}
	\item Wie ist die Pseudoinverse definiert?\newline
	\textbf{$A^+ = (A^T A)^{-1} A^T $}
\end{enumerate}
\section{title}
\begin{enumerate}[resume=b]
	\item Was ist die Idee der Konditionierung? \\
        Das Problem als Funktion modellieren, welche bei Eingabe $x$ Ausgabe $f(x)$ liefert. Ein Problem ist gut konditioniert, wenn eine kleine Pertubation (Veränderung) in $x$ auch nur eine kleine Pertubation der Ausgabe $f(x)$ bewirkt. Umgekehrt sollte klar sein.

	\item Was bedeutete es, wenn ein Problem gut konditioniert ist?\newline
	Ein Problem ist gut konditioniert, wenn eine Störung (Perturbation) in \textbf{x} auch nur eine kleine Störung in \textbf{f(x)} bewirkt. Dabei werden Perturbationen in relativen Änderungsraten gemessen mit: $\frac{\|\delta x\|}{\|x\|}, \;\frac{\|f(x+\delta x)-f(x)\|}{\|f(x)\|}$ 
	
	\item Was sind finite Differenzen? \newline
	Diskretisierung auf einem regulärem Gitter, wobei die Ableitungen Approximiert werden. \begin{enumerate}
		\item Vorwärtsdiff.: $f'[i]\approx \frac{f[i+1]-f[i]}{h}$
		\item Rückwärtsdiff.: $f'[i]\approx \frac{f[i]-f[i-1]}{h}$
		\item Zentrale Diff.: $f'[i]\approx \frac{f[i+1]-f[i-1]}{2h}$
	\end{enumerate} 
	\begin{figure}[h]    
		\includegraphics[scale=0.3]{Finitvor}
		
	\end{figure}
	$\mathop{\!\mathbin\bigtriangleup} u[i,j,t]=\frac{u[i-1,j,t]+u[i+1,j,t]+u[i,j-1,t]+u[i,j+1.t]-4u[i,j,t]}{h^2}$
	\begin{figure}[h]    
		\includegraphics[scale=0.4]{FiniteDiffs}
		
	\end{figure}
	
	\item Was bedeuten parabolisch, hyperbolisch und elliptisch?\newline
	\textbf{Parabolische PDEs beschreiben dynamische Gleichungen die gegen ein statisches Equilibrium konvergieren. Elliptische PDEs beschreiben statische Gleichgewichtszustände. 
		Hyperbolisches PDEs modellieren dynamische Systeme ohne Equilibrium.}
	\item Was besagt Diskretisierung? \\
		Grundlegende Idee: Kurve (kontinuierlich) mit einer endlichen Zahl von Parametern zu beschreiben. \\
		Dazu Kurve mittels Basisfunktionen $\varphi_j$ und Koeffizienten $f_j$ darstellen: $f(x) = \sum_{j=1}^n f_j\varphi_j(x)$.\\
		Daraus ein LGS zusammenbasteln.
	\item Wie lässt sich die erste Ableitung mittels finiter Differenzen approximieren?\newline
	Taylor-Entwicklung erster Ordnung $f(x)+hf'(x)+O(h^2)$ nach $f'(x)$ auflösen\\
	$\Rightarrow f'(x)\approx \frac{f(x+h)-f(x)}{h}$\\
	Wird $f(x)$ diskretisiert mit $f[i]=f(ih)$
	\begin{align*}
	\xRightarrow{\text{Vorwärtsdifferenz}} &f'[i]=\frac{f[i+1]-f[i]}{h}\\
	\xRightarrow{\text{Rückwärtsdifferenz}} &f'[i]=\frac{f[i]-f[i-1]}{h}\\
	\xRightarrow{\text{Zentraldifferenz}} &f'[i]=\frac{f[i+1]-f[i-1]}{2h}
	\end{align*}
	\item Was ist der Unterschied zwischen $-\mathop{\!\mathbin\bigtriangleup} u$ und $\mathop{\!\mathbin\bigtriangleup} u$? \newline
	$\mathop{\!\mathbin\bigtriangleup} u[i,j,t]=\frac{u[i-1,j,t]+u[i+1,j,t]+u[i,j-1,t]+u[i,j+1.t]-4u[i,j,t]}{h^2}$: Ausgehend von den Punkten um die Mitte wird davon der mittlere Punkt 4mal abgezogen. \\
	$\mathop{\!\mathbin\bigtriangleup} u[i,j,t]=\frac{4u[i,j,t]-u[i-1,j,t]-u[i+1,j,t]-u[i,j-1,t]-u[i,j+1.t]}{h^2}$: Ausgehen von dem mittleren Punkt, werden die umliegenden Nachbarn abgezogen. \\
	vgl. Abb. Frage 26
	\todo[inline]{Skript 59 Bild}
\end{enumerate}
\section{title}
\begin{enumerate}[resume=b]
	\item Wie sieht die Heat-Equation aus?
	\textbf{$ \dot{u}=\mathop{}\!\mathbin\bigtriangleup u$}
	\item Was besagt $\dot{U} = Laplace U$?
		Siehe vorige Frage.
	\item Was ist der explizite/implizit Euler? (Definition und Vorteile/Nachteile sowie Unterschiede)\newline
	Definition vgl. 59\\
	\begin{tabular}{c|c}
		explizit & implizit\\\hline
		\textbf{Vorteile:}&\\
		einfach zu verstehen& verwendet Zeitableitung $\dot{u}$ am nächsten Zeitpunkt $u[t+1]$\\
		einfach zu implementieren &\\
		\textbf{Nachteile:}& \\
		Instabilität bei großen Zeitsprüngen, nicht mehr $\delta t$ konvergiert & stabil für jeden Zeitschritt \\
		Fehler schaukeln stark $\rightarrow$ keine Lösung mehr möglich & höherer Rechenaufwand
	\end{tabular} 
	\item Wie kann Bildrauschen eliminiert werden? (Am Bsp.: Heat-Equation?) \newline
	
	\item Was passiert bei zu hohen Schritten im explizit Euler?
	\item Was ist die CFL-Bedingung?(Vllt?)\\
		$\delta t \le \frac{h}{||v||}$ mit $||v||$ = Informationsgeschwindigkeit.
	\item Wann ist der Gleichgewichtszustand erreicht?\newline
	Der implizite Euler konvergiert immer gegen den statischen Gleichgewichtszustand der Heat-Equation, der durch die Laplace-Equation $\delta u=0$ beschrieben wird. Während der explizite nur bei ausreichend kleinen Zeitschritten konvergiert. 	
	\item Was beschreiben die Matrizen $U$ und $V$ in der Heat-Equation? \newline 
	In $U$ werden die Höhen der Funktion an jedem Gridpunkt gespeichert. In V wird die Ableitung der Zeit in Bezug auf eine bestimmte Höhe U, also die Geschwindigkeit, gespeichert. 
	\item Was passiert mit den Randpunkten? \newline
	\textbf{Die Randpunkte in der Heat-Equation werden nicht verändert.}
	\item Wie stellt man das lineare Gleichungssystem für den Laplace auf? \newline
	\textbf{Jeder Punkt im Gitter ist eine Unbekannte die berechnet werden muss, wir haben als bei einem N x N mit Gitter N-2 Unbekannten (Randpunkte verändern sich nicht). Dies führt zu einem $(N-2)^2$ x $(N-2)^2$ Gleichungssystem $-Lu=b$.
		U ist ein Spaltenvektor in dem die neuen Werte U für das Gitter stehen. Die Reihenfolge in der die Gitterpunkte in U stehen führt zu einer Index Abbildung:$u_k=u(i,j)$ mit $k=idx(i,j)=(i-1)+(j-2)\cdot(N-2)$.
		Für die Matrix L gilt: $l_{kk}=4, l_{kl}=-1/h^2$, wenn (\={i},\={j}) Nachbarn von i,j und $l$=idx(\={i},\={j}) sonst $l_{kl}=0$.
	}
	\item Warum stellt man das lineare Gleichungssystem für den Laplace auf?
	\todo[inline]{Keine Ahnung, die Frage ist doof}
	\item Wie unterscheidet sich das Lösen des Gleichungssystems beim Laplace zu den konjugierten? \newline
	Die konjugierten Verfahren lösen dieses iterativ, während bei der Laplace Gleichung genau eine Lösung gefunden wird. Da er unabhängig vom der Zeit ist, kann die explizite Euler Integration nicht angewendet werden. 
	\item Wie löst man dieses Gl?\newline
	\textbf{Dieses Gl ist mit der \chf lösbar. Die Zeitkomplexität ist allerdings mit $O(m^3)$ hoch in diesem Fall wodurch die lösungweise durch iterative lösungverfahren besser ist.}
	\item Welche Eigenschaft hat die Laplace-Matrix?\\
		$-L$ hat folgende Eigenschaften:
		\begin{itemize}
			\item Die Matrix ist sparse: Maximal 5 Einträge pro Zeile, die ungleich null sind.
			\item $-L$ ist symmetrisch.
			\item $-L$ ist positiv definit ($L$ negativ definit).
		\end{itemize}
\end{enumerate}
\section{title}
\begin{enumerate}[resume=b]
	\item Wie funktionieren konjugierte Gradienten?
	\begin{align*}
	\text{Beliebige Suchrichtung }p_n \text{ für die Minimierung von } f(x) \text{ zulassen:}\\
	&\Rightarrow x_{n+1}=x_n+\alpha_np_n,\\
	\text{wobei }\alpha_n \text{ ähnlich zum Gradientenabstieg bestimmt werden kann:}\\
	&\frac{\delta}{\delta \alpha_n}f(x_n+\alpha_np_n) = 0\\
	&\Rightarrow \alpha_n=\frac{p_n^Tr_n}{p_n^TAp_n,} \text{ wenn }p_n=-\nabla f(x_n)=r_n \text{ äquiv. zu Gradientenabstieg}
	\end{align*}
	\item Wann werden konjugierte Gradienten angewendet? \newline
	Für große Matrizen (m>10000), da sie die Struktur ausnutzen.
	\item Was ist $\alpha$? \newline
	\textbf{$\alpha$ ist die Schrittweite in der wir uns Richtung Lösung bewegen bei einem iterativem Löser. Im Gradientenabstieg ist $\alpha=\frac{r^{T}_{n} r_n}{r^{T}_{n} A r_n}$; in konjugierten Gradienten 
		ist $\alpha=\frac{r^{T}_{n} r_n}{p^{T}_{n} A p_n}$ }
	\item Was ist die Konvergenz des Gradientenabstiegs?\\
	\includegraphics[scale=0.3]{konvergenzgradient}
	\item Wie ist der Gradientenabstieg definiert?\newline
	Löse $Ax=b, \text{ mit } A \;s.p.d.$ formuliert als Minimierung $f(x)=\frac{1}{2}x^TAx-b^Tx \rightarrow \text{min}$\\
	$f(x)$ hat ein Minimum, wenn gilt: $0=\nabla f(x)=Ax-b$\\
	minimiere $f(x)$ iterativ, indem bei jedem Schritt von $x_n$ ein Stückchen im Paraboloid heruntergelaufen wird, dies entspricht dem negativen Gradienten $-\nabla f(x)$.\\
	Da $r_n=b-Ax_n=-\nabla f(x)$ folgt $r_n$ als Abstiegsrichtung der n-ten Iteration und $x_{n+1}=x_n+\alpha_nr_n$, mit $\alpha_n=\text{arg min}_\alpha f(x_{n+1})$

	\item Was ist der Unterschied zwischen dem Gradientenabstieg und konjugierten Gradienten? \newline
	Bei dem Gradientenabstieg ist die Schrittweite abhängig von dem Resduum $r_n$. Die konjugierten Gradienten ersetzen $r_n$ durch die Suchrichtung $p_n$, wobei jedes $p_n$ einmalig vorkommt.
	\item Was ist eine Datenstruktur für eine dünnbesetzte Matrix? \newline
	\textbf{Eine einfache Datenstruktur für eine dünnbesetzte Matrix währe das Triple-Format wo alle Einträge $a_{ij} \neq 0$ in einem Tripel (i,j,v) gespeichert werden
		wobei i der Zeilenindex, j der Spaltenindex und v der Wert von $a_{ij}$ ist. Überlicherweise gespeichert als 3 Arrays für jeweils i,j,v.}
	\item Was sind die Vorteile von konjugierten Gradienten?\\
	\begin{itemize}
		\item Fehler $ \|e_n\|_A$ nimmt monoton ab.
		\item Der Algorithmus terminiert nach maximal $m$ Iterationen. 
		\item Aufwand $O(m^2)$, typischerweise $O(m^{1.5}$.
		\item Speicheraufwand $O(m)$.
		\item Algorithmus muss nicht direkt auf Matrix-Einträge zugreifen. Daher Nutzung einer effizienten Datenstruktur für das Matrix-Vektorprodukt $Ap$ möglich.
	\end{itemize}
	\item Was ist ein Stopkriterium von konjugierten Gradienten?\newline
	Wenn $A^{n\times n}$ dann kann man nach maximal $n$-Schritte aufhören, ebenso wenn wenn $\beta<\epsilon$
\end{enumerate}
\section{title}
\begin{enumerate}[resume=b]
	\item Wie ist die Wave-Equation definiert? Wie kann man sie als PDE erster Ordnung schreiben? \newline
	$\ddot{u}=c^2 \mathop{\!\mathbin\bigtriangleup}u$. Durch eine Hilfsfunktion $v:=\dot{u}$ kann die Gleichung wie folgt modelliert werden: $\dot{u}=v$ $\dot{v}=c^2\mathop{\!\mathbin\bigtriangleup}u$
	\item Was erfordert eine doppelt so große Wellengeschwindigkeit? \newline
	\textbf{Eine doppelt so hohe Wellenggeschwindigkeit erfordert einen halb so großem Zeitschritt, damit die explizite Integration nicht instabil wird und weiterhin die CFL bedingung erfüllt. }
	\item Wie diskretisiert man die PDE's mit finiten Differenzen im Falle der Wave-Equation? \newline
	$u[i,j,t]=u(ih,jh,t\delta t)$, $v[i,j,t]=v(ih,jh,t\delta t)$. Die PDEs hängen num im 2-dim Gitter von Raum und Zeit ab.
	\item Wieso müssen Zeitschritte manchmal gesplittet werden?\newline
	Um im expliziten Euler eine große Wellengeschwindigkeit zu berechnen, müssen Zeitschritte gesplittet werden.
	\item Welche Randbedingungen sind möglich?\newline 
	\begin{enumerate}
		\item periodisch
		\item gespiegelt
		\item Null
	\end{enumerate}
	\item Was ist der Unterschied zwischen implizit und explizit?(vlg Heat.) \newline
	\textbf{Explizite Integration berechnet die Werte des nächsten Zeitpunktes $u[t+1]$ aus dem momentaren Werten am Punkt sowie dessen Nachbarn: $u[t+1]=u[t]+\delta t \mathop{}\!\mathbin\bigtriangleup u[t]$.
		Implizite Integration berechnet die Werte des nächsten Zeitpunktes $u[t+1]$ mithilfe des nächsten Zeitpunktes: $u[t+1]=u[t]+\delta t \mathop{}\!\mathbin\bigtriangleup u[t+1]$.
		Zum berechnen von $u[t+1]$ müssen wir das Gleichungssystem:$(I-\delta t \mathop{}\!\mathbin\bigtriangleup )u[t+1]=u[t]$ lösen.}
	\item Wie sieht das lineare Gleichungssystem im impliziten Fall im Vergleich zum expliziten (Wave Equation) aus? \\
		Im expliziten Fall kann das Gleichungssystem in einem Schritt gelöst werden, da die Gleichungen nicht voneinander abhängen. Im impliziten Fall hängt $v_{t+1}$ aber von $u_{t+1}$ ab und umgekehrt, und muss daher als Gleichungssystem gelöst werden: \\
	\begin{itemize}
		\item $\left( I - \delta t^2 c^2 L \right)v_{t+1} = v_t \delta t c^2Lu_t$.
		\item Dabei ist $A = \left( I - \delta t^2 c^2 L \right)$, $ x = v_{t+1}$ (gesucht) und
		$b = v_t \delta t c^2Lu_t$
	\end{itemize}
\end{enumerate}
\section{sparse \chf}
\begin{enumerate}[resume=b]
	\item Was ist der Unterschied von sparse \chf und normaler \chf?\newline
	Für die sparse Matrix $A$ wird die Spalte $j$ nicht mehr durch all Spalten $k<j$ aus $L$ modifiziert. Die $j$-Spalte wird nur noch durch die Spalten $k$ modifiziert, für die $l_{jk}\neq0$ ist.
	\item Was sind fill-ins? \newline
	s. Frage 19
	\item Was ist eine Bandmatrix? \newline
	\textbf{Eine Bandmatrix ist eine dünnbesetzte Matrix deren Nicht-Null-Einträge sich auf ein 'Band' um die Diagonale der Matrix beschränken. wobei die Bandbreite $\beta(A)$ definiert ist als die maximale Distanz eienr nicht-Null von der diogonalen der Matrix A.}
	\includegraphics{bandmatrix.png}
	\item Kommt in der sparse \chf fill-in vor?
	\item Welche Schritte muss man im sparse \chf machen?\newline
	Ändere die Reihenfolge der $x_i$ mittels Permutationsmatrix $P$ , so dass $\tilde{x}=Px$\\
	Sortiere analog $A$ um; also $\hat{A}=AP^T$. Da $A$ nun nicht mehr symmetrisch, permutiere nun auch die Zeilen von $A$ und $b$ respektive $\tilde{A}=P\hat{A}=PAP^T$, $\tilde{b}=Pb$.\\ 
	Wende nun Cholesky auf $\tilde{A}\tilde{x}=\tilde{b}$ an.
	\item Welche Vorteile hat der Sparse \chf? \newline
	Effizientes, robustes Verfahren für dünn-besetzte Matruzen. Durch eine Umsortierung der Matrix kann es keine fill-ins geben. Durch die Konstruktion von $\tilde{L}$ enthält sie weniger 0en.
	\item Was ist die Band-\chf? \newline
	\textbf{Zunächst lege eine Band-matrix-Datenstruktur für L an. der Speicherverbauch ist nun $O(mb)$ anstatt $O(m^2)$, wobei b die bandbreite von der Bandmatrix ist. Bei der Berechnung der $l_{ij}$ von L müssen nur Einträge $l_{ij} \in Band(L)$ berücksichtigt werden, da alle anderen einträge null sind. Dies reduziert den Rechenaufwand von $O(m^3)$ auf $O(mb^2)$
		Löse nun $Ly=b$ und $L^Tx=y$ unter ausnutzung der Bandbegrenzung von L, dies reduziert den aufwand von $O(m^2$ auf $O(mb)$}
	\todo[inline]{Bilder 102}
	\item Wieso macht man den Band-\chf und was ist der Vorteil davon?
	\item Was macht der Minimum degree-Algorithmus?\newline
	Ziel: Permutation finden, sodass $LL^T=PAP^T$ möglichst wenig fill-in besitzt.\\
	Dazu suche den Knoten $v$ mit den wenigsten Kanten und nummeriere diesen. Des Weiteren verbinde die Nachbarn von $v$ mit einander.
\end{enumerate}
\section{title}
\begin{enumerate}[resume=b]
	\item Wie parallelisiert man? \newline
	Auf einem Prozess mittels SIMD und SSE. Auf mehreren Prozessoren mittel OpenMP (1 Masterthread). Der Code von OpenMP ist: \\
	\# pragma omp parallel
	\\
	id = omp\_get\_thread\_num ();  Welcher Thread ?\\
	int nthreads = omp\_get\_num\_threads () Wieviele? \\
	\item Welche Kommandozeilen Argumente? \newline
	\textbf{\begin{itemize}
			\item -O: schaltet einfache optimierungen ein
			\item -O3: mehr Optimierungen, insbesondere function inlining
			\item -Ofast: noch mehr Optimierungen kann aber Ergebnisse verändern!
			\item --march=native: Aktiviert die passenden AVX/SSE/SSE3 Instruktionen
			\item -fexpensive-optimizations: Noch mehr Optimierungen
			\item -funroll-loops Schreibt Schleifen aus.
			\item -ftree-vectorize: Automatische SSE-Vektorisierung
		\end{itemize}
	}
	\item Worauf muss man bei Parallelisierung achten?\newline
	Zu beachten ist, dass manche Variablen private gesetzt werden müssen und dass der Speicherzugriff eindeutig sein muss, also Ergebnisse seperat gespeichert werden müssen.
	\item Wie kann man Code optimieren?\newline
	Bsp.:Call by Reference, Return by Reference, Inlinen von Funktionen
\end{enumerate}
\end{document}
